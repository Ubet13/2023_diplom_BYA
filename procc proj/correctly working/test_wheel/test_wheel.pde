/* autogenerated by Processing revision 1283 on 2022-07-26 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;
import processing.*;
import java.*;
import g4p_controls.GWindow;
import g4p_controls.*;



GButton btnMOVE;
GButton btnTENS;
GButton btnHP;
GButton btnCOEF1;
GCustomSlider sldrX;
GCustomSlider sldrY;
GTextBase nmb_X;
GTextBase nmb_Y;


float  wheel;
PVector Pos_of_main;
Table table, tableE;
int n=3000000;
float [][][] xx = new float[n][5][4];
float [][][] xd = new float[n][5][4];
float [][][] xt = new float[n][5][4];
float [][][] hp = new float[n][5][4];
float max_hp=3300000000.0;
float []tension_x =  new float[n];
float []tension_y =  new float[n];

//float [][][] xd = new float[n][5][4];
int ee=0;
int ee1;
int k, k1, k2, k3;
int x, y;
int n2=100;
int nF=100;
int [][] F = new int[nF][nF];

//float   min1=0;
//float   min2=0;
//float Sc=0.8;
//float max1=0;
//float max2=0;
float [][] xg = new float[n2+10][6];
float e, coef;
float [][][] constr=new float[n][5][4];
float displayWidth_rect_1;
float displayWidth_rect_2;
float displayHeight_rect_1;
float displayHeight_rect_2;
float xc, yc, zc, dx, dy, dz, r1, r2, r3, xb1, xb2, xb3, yb1, yb2, yb3, rb, s;



PImage lin, cur, cir, back, b1, b2;

float Sc=0.8;
float max1=0;
float max2=0;

float   min1=0;
float   min2=0;

float Scd=200;
boolean state_C=false;
boolean state_b1=false;
boolean state_b2=false;
boolean state_b3=false;
int imax1=0;
int imax2=0;
int Fpr1, Fpr2;


void settings() {
  size(displayWidth, displayHeight, P3D);

  table = loadTable("data.csv", "header");
  tableE = loadTable("tensionE.csv", "header");
  k1=0;
  k=0;
  xc=0;
  yc=0;
  zc=0;
  displayWidth_rect_1=displayWidth*4/16;
  displayWidth_rect_2=displayWidth;
  displayHeight_rect_1=displayHeight;
  displayHeight_rect_2=displayHeight*2/16;

  println(displayWidth, displayHeight);
  for (TableRow row : table.rows()) {  // загрузка координат в массив
    ee = row.getInt(0);
    k1=k1+1;

    xx[k1][0][0] = row.getFloat(1)*0.03f;// координата X
    xx[k1][1][0] = row.getFloat(5)*0.03f;// координата Y
    xx[k1][2][0] = row.getFloat(9)*0.03f;// координата Z

    xx[k1][0][1] = row.getFloat(2)*0.03f;// компоненты вектора перемещений при действии нагружения 1 X
    xx[k1][1][1] = row.getFloat(6)*0.03f;// компоненты вектора перемещений при действии нагружения 1 Y
    xx[k1][2][1] = row.getFloat(10)*0.03f;// компоненты вектора перемещений при действии нагружения 1 Z

    xx[k1][0][2] = row.getFloat(3)*0.03f;// компоненты вектора перемещений при действии нагружения 2 X
    xx[k1][1][2] = row.getFloat(7)*0.03f;// компоненты вектора перемещений при действии нагружения 2 Y
    xx[k1][2][2] = row.getFloat(11)*0.03f;// компоненты вектора перемещений при действии нагружения 2 Z

    xx[k1][0][3] = row.getFloat(4)*0.03f;//
    xx[k1][1][3] = row.getFloat(8)*0.03f;//
    xx[k1][2][3] = row.getFloat(12)*0.03f;//

    xd[k1][0][0] = row.getFloat(13)*0.002f;//
    xd[k1][0][1] = row.getFloat(17)*0.002f;//
    xd[k1][0][2] = row.getFloat(21)*0.002f;//
  }
  k3=0;
  for (TableRow rowE : tableE.rows()) {  // загрузка координат в массив
    ee = rowE.getInt(0);
    xt[k3][0][0] =rowE.getFloat(11);// Von-mises X
    // println(xt[k1][0][0]);
    xt[k3][1][0] = xt[k3][0][0];// Von-mises Y
    k3=k3+1;
  }

  //println(k1);
}



public void setup() {
  surface.setResizable(true);
  surface.setLocation(100, 100);
  coef=1;
  nmb_X=new GTextField (this, 40, 800, 200, 60);
  nmb_Y=new GTextField (this, 40, 1000, 200, 60);
  sldrX = new GCustomSlider(this, 40, 300, 200, 60, null);
  sldrY = new GCustomSlider(this,40, 500, 200, 60, null);
  btnMOVE = new GButton(this, 510, 20, 140, 40, "Режим отображения перемещений");
  btnTENS = new GButton(this, 810, 20, 140, 40, "Режим отображения напряжений");
  btnHP = new GButton(this, 1110, 20, 140, 40, "Режим отображения запаса хп");
  btnCOEF1 = new GButton(this, 1410, 20, 140, 40, "Вернуть нужный размер конструкции");
  lin = loadImage("lin2.png");
  cur = loadImage("cur.png");
  cir = loadImage("s2.png");
  b1 = loadImage("b1.png");
  b2 = loadImage("b2.png");
  back = loadImage("back2.png");
  back.resize(int(displayWidth_rect_2), int(displayHeight_rect_1));

  //imageMode(CENTER);
  //rectMode(CENTER);
  xb1=displayWidth*0.7;
  yb1=displayHeight*0.15;
  xb2=displayWidth*0.8;
  yb2=displayHeight*0.15;
  xb3=displayWidth*0.9;
  yb3=displayHeight*0.15;
  rb=displayHeight*0.15;
}



public void draw() {

  background(100, 100, 100);

  rect(0, 0, displayWidth_rect_1, displayHeight_rect_1);
  fill(255);
  rect(0, 0, displayWidth_rect_2, displayHeight_rect_2);
  fill(255);

  translate(width*5/8, height*0.85);
  rotateX(PI/2);
  rotateZ(PI/4);

  if (wheel==1) {
    coef=coef-0.03;
    if (coef<0)
    {
      coef=0;
    }
    if (coef>1.1)
    {
      coef=1.15;
    }
  }
  if (wheel==-1) {
    coef=coef+0.03;
    if (coef<0)
    {
      coef=0;
    }
    if (coef>1.1)
    {
      coef=1.1;
    }
  }

  fill(255);
  stroke(255);

  thread("requestData1");

  thread("requestData2");

  thread("requestData3");

  thread("requestData4");

  thread("requestData5");

  thread("requestData6");

  thread("requestData7");

  if (state_b1) {//режим отображения перемещений
    for (int i = 0; i < k1; i++) {
      //if (mouseX>displayWidth_rect_1 && mouseY>displayHeight_rect_2 ) {
        stroke(int(tension_x[i])*50, 0, int(tension_y[i])*50, 100);
        //println(tension_x[i]*50, 0, tension_y[i]*50);
        point(constr[i][0][0], constr[i][0][1], constr[i][0][2]);
     // }
    }
  }

  if (state_b2) {//режим отображения напряжений
    for (int i = 0; i < k1; i++) {
      //if (mouseX>displayWidth_rect_1 && mouseY>displayHeight_rect_2 ) {
        stroke(s, xt[i][0][0]*40*abs(mouseX-displayWidth*5/8)/displayWidth, xt[i][0][0]*40*abs(mouseY-displayHeight*1/2)/displayHeight);
        //stroke(255,255,255);
        point(xx[i][0][0]*coef, xx[i][1][0]*coef, xx[i][2][0]*coef);
        //println(s, xt[i][0][0]*40*abs(mouseX-displayWidth*5/8)/displayWidth, xt[i][0][0]*40*abs(mouseY-displayHeight*1/2)/displayHeight);
      //}
    }
  }

  if (state_b3) {//режим отображения запаса хп
    for (int i = 0; i < k1; i++) {
      //if (mouseX>displayWidth_rect_1 && mouseY>displayHeight_rect_2 ) {
        stroke(255*( (hp[i][0][0]+hp[i][1][0])/max_hp), 0, 0);
        //println(hp[i][0][0], 0, hp[i][1][0]);
        point(xx[i][0][0]*coef, xx[i][1][0]*coef, xx[i][2][0]*coef);
     // }
    }
  }
  wheel=0;
}

public void mouseWheel(MouseEvent event) {
  float e = event.getCount();
  println(e);
  wheel=e;
}

void requestData1() {
  if (state_b1) {
    for (int i = 0; i < n/4; i++) {
      if (mouseX>displayWidth_rect_1 && mouseY>displayHeight_rect_2) {
        constr[i][0][0]=(xx[i][0][0]+xd[i][0][0]*float(mouseX-displayWidth*5/8))*coef;
        constr[i][0][1]=(xx[i][1][0]+xd[i][0][1]*float(mouseY-displayHeight*1/2))*coef;
        constr[i][0][2]=(xx[i][2][0]+xd[i][0][2]*float(mouseX-displayWidth*5/8))*coef;
      }
    }
  }
}
void requestData2() {
  if (state_b1) {
    for (int i = n/4; i < n/2; i++) {

      if (mouseX>displayWidth_rect_1 && mouseY>displayHeight_rect_2) {
        constr[i][0][0]=(xx[i][0][0]+xd[i][0][0]*float(mouseX-displayWidth*5/8))*coef;
        constr[i][0][1]=(xx[i][1][0]+xd[i][0][1]*float(mouseY-displayHeight*1/2))*coef;
        constr[i][0][2]=(xx[i][2][0]+xd[i][0][2]*float(mouseX-displayWidth*5/8))*coef;
      }
    }
  }
}
void requestData3() {
  if (state_b1) {
    for (int i = n/2; i < n*3/4; i++) {
      if (mouseX>displayWidth_rect_1 && mouseY>displayHeight_rect_2) {
        constr[i][0][0]=(xx[i][0][0]+xd[i][0][0]*float(mouseX-displayWidth*5/8))*coef;
        constr[i][0][1]=(xx[i][1][0]+xd[i][0][1]*float(mouseY-displayHeight*1/2))*coef;
        constr[i][0][2]=(xx[i][2][0]+xd[i][0][2]*float(mouseX-displayWidth*5/8))*coef;
      }
    }
  }
}
void requestData4() {
  if (state_b1) {
    for (int i = n*3/4; i < n; i++) {
      if (mouseX>displayWidth_rect_1 && mouseY>displayHeight_rect_2) {
        constr[i][0][0]=(xx[i][0][0]+xd[i][0][0]*float(mouseX-displayWidth*5/8))*coef;
        constr[i][0][1]=(xx[i][1][0]+xd[i][0][1]*float(mouseY-displayHeight*1/2))*coef;
        constr[i][0][2]=(xx[i][2][0]+xd[i][0][2]*float(mouseX-displayWidth*5/8))*coef;
      }
    }
  }
}

void requestData5() {
  if (state_b1) {
    for (int i = 0; i < n; i++) {
      if (mouseX>displayWidth_rect_1 && mouseY>displayHeight_rect_2) {
        tension_x[i]=xt[i][0][0]*float(abs(mouseX-displayWidth*5/8))/float(displayWidth);
        tension_y[i]=xt[i][1][0]*float(abs(mouseY-displayHeight*4/8))/float(displayHeight);
      }
    }
  }
}
void requestData6() {
  if (state_b2) {
    for (int i = 0; i < n; i++) {
      if (mouseX>displayWidth_rect_1 && mouseY>displayHeight_rect_2) {
        s=xt[i][0][0]*abs(mouseX-displayWidth*5/8)/displayWidth+xt[i][1][0]*abs(mouseY-displayHeight*1/2)/displayHeight;
      }
    }
  }
}
void requestData7() {
  if (state_b3) {
    for (int i = 0; i < n; i++) {
      if (mouseX>displayWidth_rect_1 && mouseY>displayHeight_rect_2) {
        hp[i][0][0]=hp[i][0][0]+xt[i][0][0]*float(abs(mouseX-displayWidth*5/8))/float(displayWidth);
        hp[i][1][0]=hp[i][1][0]+xt[i][1][0]*float(abs(mouseY-displayHeight*4/8))/float(displayHeight);
      }
    }
  }
}
public void handleButtonEvents(GButton button, GEvent event) {
  if (button == btnMOVE && event == GEvent.CLICKED) {
    state_b1=true;
    state_b2=false;
    state_b3=false;
    //println("Button 'btnMOVE' was clicked");
  }
  if (button == btnTENS && event == GEvent.CLICKED) {
    state_b1=false;
    state_b2=true;
    state_b3=false;
    //println("Button 'btnTENS' was clicked");
  }
  if (button == btnHP && event == GEvent.CLICKED) {
    state_b1=false;
    state_b2=false;
    state_b3=true;
    //println("Button 'btnHP' was clicked");
  }
  if (button == btnCOEF1 && event == GEvent.CLICKED) {
    coef=1.0;
    //println("Button 'btnHP' was clicked");
  }
}
