/* autogenerated by Processing revision 1283 on 2022-07-26 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;
import processing.*;
import java.*;
import g4p_controls.GWindow;
import g4p_controls.*;



GButton btnMOVE;
GButton btnTENS;
GButton btnHP;
GButton btnCOEF1;
GCustomSlider sldrX;
GCustomSlider sldrY;
GTextBase nmb_X;
GTextBase nmb_Y;

float X_float, Y_float;
float  wheel;
PVector Pos_of_main;
Table table, tableE;
int n=3000000;
float [][][] xx = new float[n][5][4];
float [][][] xd = new float[n][5][4];
float [][][] xt = new float[n][5][4];
float [][][] hp = new float[n][5][4];
float max_hp=3300000000.0;
float []tension_x =  new float[n];
float []tension_y =  new float[n];

//float [][][] xd = new float[n][5][4];
int ee=0;
int ee1;
int k, k1, k2, k3;
int x, y;
int n2=100;
int nF=100;
int [][] F = new int[nF][nF];

float [][] xg = new float[n2+10][6];
float e, coef;
float [][][] constr=new float[n][5][4];
float displayWidth_rect_1;
float displayWidth_rect_2;
float displayHeight_rect_1;
float displayHeight_rect_2;
float xc, yc, zc, dx, dy, dz, r1, r2, r3, xb1, xb2, xb3, yb1, yb2, yb3, rb, s;



PImage lin, cur, cir, back, b1, b2;

float Sc=0.8;
float max1=0;
float max2=0;

float   min1=0;
float   min2=0;

float Scd=200;
boolean state_C=false;
boolean state_b1=false;
boolean state_b2=false;
boolean state_b3=false;
int imax1=0;
int imax2=0;
int Fpr1, Fpr2;


void settings() {
  size(displayWidth, displayHeight, P3D);

  table = loadTable("data.csv", "header");
  tableE = loadTable("tensionE.csv", "header");
  k1=0;
  k=0;
  xc=0;
  yc=0;
  zc=0;
  displayWidth_rect_1=displayWidth*4/16;
  displayWidth_rect_2=displayWidth;
  displayHeight_rect_1=displayHeight;
  displayHeight_rect_2=displayHeight*2/16;

  println(displayWidth, displayHeight);
  for (TableRow row : table.rows()) {  // загрузка координат в массив
    ee = row.getInt(0);
    k1=k1+1;

    xx[k1][0][0] = row.getFloat(1)*0.03f;// координата X
    xx[k1][1][0] = row.getFloat(5)*0.03f;// координата Y
    xx[k1][2][0] = row.getFloat(9)*0.03f;// координата Z

    xx[k1][0][1] = row.getFloat(2)*0.03f;// компоненты вектора перемещений при действии нагружения 1 X
    xx[k1][1][1] = row.getFloat(6)*0.03f;// компоненты вектора перемещений при действии нагружения 1 Y
    xx[k1][2][1] = row.getFloat(10)*0.03f;// компоненты вектора перемещений при действии нагружения 1 Z

    xx[k1][0][2] = row.getFloat(3)*0.03f;// компоненты вектора перемещений при действии нагружения 2 X
    xx[k1][1][2] = row.getFloat(7)*0.03f;// компоненты вектора перемещений при действии нагружения 2 Y
    xx[k1][2][2] = row.getFloat(11)*0.03f;// компоненты вектора перемещений при действии нагружения 2 Z

    xx[k1][0][3] = row.getFloat(4)*0.03f;//
    xx[k1][1][3] = row.getFloat(8)*0.03f;//
    xx[k1][2][3] = row.getFloat(12)*0.03f;//

    xd[k1][0][0] = row.getFloat(13)*0.002f;//
    xd[k1][0][1] = row.getFloat(17)*0.002f;//
    xd[k1][0][2] = row.getFloat(21)*0.002f;//
  }
  k3=0;
  for (TableRow rowE : tableE.rows()) {  // загрузка координат в массив
    ee = rowE.getInt(0);
    xt[k3][0][0] =rowE.getFloat(11);// Von-mises X

    xt[k3][1][0] = xt[k3][0][0];// Von-mises Y
    k3=k3+1;
  }
}



public void setup() {
  surface.setResizable(true);
  surface.setLocation(100, 100);
  coef=1;
  nmb_X=new GTextField (this, 40, 800, 200, 60);
  nmb_Y=new GTextField (this, 40, 1000, 200, 60);
  sldrX = new GCustomSlider(this, 40, 300, 200, 60, null);
  sldrY = new GCustomSlider(this, 40, 500, 200, 60, null);
  btnMOVE = new GButton(this, 530, 20, 140, 40, " ");
  btnTENS = new GButton(this, 830, 20, 140, 40, " ");
  btnHP = new GButton(this, 1110, 20, 140, 40, " ");
  btnCOEF1 = new GButton(this, 1460, 20, 140, 40, " ");
  lin = loadImage("lin2.png");
  cur = loadImage("cur.png");
  cir = loadImage("s2.png");
  b1 = loadImage("b1.png");
  b2 = loadImage("b2.png");
  back = loadImage("back2.png");
  back.resize(int(displayWidth_rect_2), int(displayHeight_rect_1));

  xb1=displayWidth*0.7;
  yb1=displayHeight*0.15;
  xb2=displayWidth*0.8;
  yb2=displayHeight*0.15;
  xb3=displayWidth*0.9;
  yb3=displayHeight*0.15;
  rb=displayHeight*0.15;
}



public void draw() {

  background(100, 100, 100);

  rect(0, 0, displayWidth_rect_1, displayHeight_rect_1);
  fill(255);
  rect(0, 0, displayWidth_rect_2, displayHeight_rect_2);
  fill(255);
  
  textSize(20);
  fill(0, 0, 0);
  text("Отображения перемещений", 490, displayHeight_rect_2/2+20);
  text("Отображения напряжений", 780, displayHeight_rect_2/2+20);
  text("Отображения запаса прочности", 1060, displayHeight_rect_2/2+20);
  text("Вернуть исходный размер конструкции", 1400, displayHeight_rect_2/2+20);
  text("Составляющая по оси Х="+(X_float-0.5)*2, 10, height*3/8-20);
  text("Составляющая по оси Y="+(Y_float-0.5)*2, 10, height*5/8-20);

  translate(width*5/8, height*0.85);
  rotateX(PI/2);
  rotateZ(PI/4);

  if (wheel==1) {
    coef=coef-0.03;
    if (coef<0)
    {
      coef=0;
    }
    if (coef>1.1)
    {
      coef=1.15;
    }
  }
  if (wheel==-1) {
    coef=coef+0.03;
    if (coef<0)
    {
      coef=0;
    }
    if (coef>1.1)
    {
      coef=1.1;
    }
  }

  fill(255);
  stroke(255);

  thread("requestData1");

  thread("requestData2");

  thread("requestData3");

  thread("requestData4");

  thread("requestData5");

  thread("requestData6");

  thread("requestData7");

  if (state_b1) {//режим отображения перемещений
    for (int i = 0; i < k1; i++) {
      stroke(int(tension_x[i])*50, 0, int(tension_y[i])*50, 100);
      point(constr[i][0][0], constr[i][0][1], constr[i][0][2]);
    }
  }

  if (state_b2) {//режим отображения напряжений
    for (int i = 0; i < k1; i++) {
      stroke(s, xt[i][0][0]*40*abs(X_float-0.5)*2, xt[i][0][0]*40*abs(Y_float-0.5)*2);
      point(xx[i][0][0]*coef, xx[i][1][0]*coef, xx[i][2][0]*coef);
    }
  }

  if (state_b3) {//режим отображения запаса хп
    for (int i = 0; i < k1; i++) {
      stroke(255*( (hp[i][0][0]+hp[i][1][0])/max_hp), 0, 0);
      point(xx[i][0][0]*coef, xx[i][1][0]*coef, xx[i][2][0]*coef);
    }
  }
  wheel=0;
}

public void mouseWheel(MouseEvent event) {
  float e = event.getCount();
  println(e);
  wheel=e;
}

void requestData1() {
  if (state_b1) {
    for (int i = 0; i < n/4; i++) {
      //  if (mouseX>displayWidth_rect_1 && mouseY>displayHeight_rect_2) {
      constr[i][0][0]=(xx[i][0][0]+xd[i][0][0]*(X_float-0.5)*500)*coef;
      constr[i][0][1]=(xx[i][1][0]+xd[i][0][1]*(Y_float-0.5)*500)*coef;
      constr[i][0][2]=(xx[i][2][0]+xd[i][0][2]*(Y_float-0.5)*500)*coef;
      //  }
    }
  }
}
void requestData2() {
  if (state_b1) {
    for (int i = n/4; i < n/2; i++) {

      // if (mouseX>displayWidth_rect_1 && mouseY>displayHeight_rect_2) {
      constr[i][0][0]=(xx[i][0][0]+xd[i][0][0]*(X_float-0.5)*500)*coef;
      constr[i][0][1]=(xx[i][1][0]+xd[i][0][1]*(Y_float-0.5)*500)*coef;
      constr[i][0][2]=(xx[i][2][0]+xd[i][0][2]*(Y_float-0.5)*500)*coef;
      // }
    }
  }
}
void requestData3() {
  if (state_b1) {
    for (int i = n/2; i < n*3/4; i++) {
      // if (mouseX>displayWidth_rect_1 && mouseY>displayHeight_rect_2) {
      constr[i][0][0]=(xx[i][0][0]+xd[i][0][0]*(X_float-0.5)*500)*coef;
      constr[i][0][1]=(xx[i][1][0]+xd[i][0][1]*(Y_float-0.5)*500)*coef;
      constr[i][0][2]=(xx[i][2][0]+xd[i][0][2]*(Y_float-0.5)*500)*coef;
      // }
    }
  }
}
void requestData4() {
  if (state_b1) {
    for (int i = n*3/4; i < n; i++) {
      // if (mouseX>displayWidth_rect_1 && mouseY>displayHeight_rect_2) {
      constr[i][0][0]=(xx[i][0][0]+xd[i][0][0]*(X_float-0.5)*500)*coef;
      constr[i][0][1]=(xx[i][1][0]+xd[i][0][1]*(Y_float-0.5)*500)*coef;
      constr[i][0][2]=(xx[i][2][0]+xd[i][0][2]*(Y_float-0.5)*500)*coef;
      //}
    }
  }
}

void requestData5() {
  if (state_b1) {
    for (int i = 0; i < n; i++) {
      //if (mouseX>displayWidth_rect_1 && mouseY>displayHeight_rect_2) {
      tension_x[i]=xt[i][0][0]*abs(X_float-0.5)*2;
      tension_y[i]=xt[i][1][0]*abs(Y_float-0.5)*2;
      //}
    }
  }
}
void requestData6() {
  if (state_b2) {
    for (int i = 0; i < n; i++) {
      //if (mouseX>displayWidth_rect_1 && mouseY>displayHeight_rect_2) {
      s=xt[i][0][0]*abs(X_float-0.5)*2+xt[i][1][0]*abs(Y_float-0.5)*2;
      // }
    }
  }
}
void requestData7() {
  if (state_b3) {
    for (int i = 0; i < n; i++) {
      //if (mouseX>displayWidth_rect_1 && mouseY>displayHeight_rect_2) {
      hp[i][0][0]=hp[i][0][0]+xt[i][0][0]*abs(X_float-0.5)*2;
      hp[i][1][0]=hp[i][1][0]+xt[i][1][0]*abs(Y_float-0.5)*2;
      // }
    }
  }
}
public void handleButtonEvents(GButton button, GEvent event) {
  if (button == btnMOVE && event == GEvent.CLICKED) {
    state_b1=true;
    state_b2=false;
    state_b3=false;
    //println("Button 'btnMOVE' was clicked");
  }
  if (button == btnTENS && event == GEvent.CLICKED) {
    state_b1=false;
    state_b2=true;
    state_b3=false;
    //println("Button 'btnTENS' was clicked");
  }
  if (button == btnHP && event == GEvent.CLICKED) {
    state_b1=false;
    state_b2=false;
    state_b3=true;
    //println("Button 'btnHP' was clicked");
  }
  if (button == btnCOEF1 && event == GEvent.CLICKED) {
    coef=1.0;
    //println("Button 'btnHP' was clicked");
  }
}

public void handleSliderEvents(GValueControl slider, GEvent event) {
  // println("Slider Value " + sldrX.getValueI());
  println( sldrX.getValueF());
  X_float = sldrX.getValueF();
  // println("Slider Value " + sldrY.getValueI());
  println( sldrY.getValueF());
  Y_float = sldrY.getValueF();
}
public void handleTextEvents(GEditableTextControl textcontrol, GEvent event)
{
  println("Button 'btnHP' was clicked");
}
